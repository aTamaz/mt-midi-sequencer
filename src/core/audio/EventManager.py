import EventWorkerimport OutputAdapterimport core.audio.Sequence as Sequenceimport timeimport threadingimport Queueimport core.Constants as Constantsimport sys'''Singleton ImplementationMeta-Info: If ever someone creates a module named EventManagerInstance, there will be problems!'''def getInstance():	if ('EventManagerInstance' not in sys.modules):		manager=EventManager(logging=Constants.LOGGING_eventSystem)		sys.modules['EventManagerInstance']=manager		manager.start()	return sys.modules['EventManagerInstance']	'''- Class: EventManager- Description:This class is the worker's manager. Here we can register new objectswith callback functions while the worker is busy working'''class EventManager(threading.Thread):	def __init__(self, **kwargs):		kwargs.setdefault('logging', True)		self.__logging = kwargs.get('logging')		self.__log('initializing EventManager')		# thread safe queue for music data		self.playDataQueue=Queue.Queue(maxsize=Constants.EventManager_playDataQueue_maxsize) #32		# mandatory for threading		threading.Thread.__init__(self)		# setup worker		self.worker=EventWorker.EventWorker(manager=self, logging=self.__logging)		self.worker.setDaemon(True)		# setup output		self.output=OutputAdapter.OutputAdapter(manager=self, logging=self.__logging)		self.output.setDaemon(True)		self.__callbacks={} # dictionary for callback methods <obj>:<callback>		__singleton = self				self.__sequenceCounter = -1	''' register an object '''	def register(self, object, method):		self.__log('registering callback method for ' + str(object.id))		self.__callbacks[object]=method		# tell worker to get new registered method:		self.worker.refreshConfig.set()	''' unregister an object '''	def unregister(self, object):		self.__log('unregistering callback method for ' + str(object.id))		del self.__callbacks[object]		# tell worker to get new registered method:		self.worker.refreshConfig.set()			''' for EventWorker to fetch it '''	def getCallbacks(self):		return self.__callbacks	''' set speed in bpm = beats per minute '''	def setBPM(self,bpm):		self.output.setBPM(bpm)	''' tunnel for log messages '''	def __log(self, msg):		if(self.__logging):			print 'EventManager:\t' + msg	''' get next Sequence ID from internal counter 		this method should be used each time a sequence		is instantiated so there are no duplicates	'''	def getNextSequenceID(self):		self.__sequenceCounter = self.__sequenceCounter + 1		print self.__sequenceCounter		return self.__sequenceCounter				''' make new sequence '''	def createSequence(self):		seq = Sequence.Sequence(id=self.getNextSequenceID(),logging=Constants.LOGGING_sequences)		self.register(seq, seq.getMidiData)		return seq	''' mainloop '''	def run(self):		# start EventWorker-Thread		self.__log('starting EventWorker-Thread')		self.worker.start()		# start OutputAdapter-Thread		self.__log('starting OutputAdapter-Thread')		self.output.start()		