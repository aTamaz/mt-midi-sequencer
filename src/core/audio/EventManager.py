import EventWorker#import OutputAdapterimport core.audio.Sequence as Sequenceimport core.audio.Output as OutputAdapterimport timeimport threadingimport Queueimport core.Constants as Constantsimport sysimport pygameimport pygame.midifrom pygame.locals import *'''Singleton ImplementationMeta-Info: If ever someone creates a module named EventManagerInstance, there will be problems!'''def getInstance():	if ('EventManagerInstance' not in sys.modules):		raise Exception('You must start EventManager first in order to get a running instance.')	return sys.modules['EventManagerInstance']	'''- Class: EventManager- Description:This class is the worker's manager. Here we can register new objectswith callback functions while the worker is busy working'''class EventManager(threading.Thread):	def __init__(self, **kwargs):		kwargs.setdefault('logging', True)		self.__logging = kwargs.get('logging')		self.__log('initializing EventManager')		# thread safe queue for music data		self.playDataQueue=Queue.Queue(maxsize=Constants.EventManager_playDataQueue_maxsize) #32		# mandatory for threading		threading.Thread.__init__(self)		# setup worker		self.worker=EventWorker.EventWorker(manager=self, logging=self.__logging)		#self.worker.setDaemon(True)		'''		# pygame		device_id = None		pygame.init()		pygame.midi.init()		self._print_device_info()		if device_id is None:			port = pygame.midi.get_default_output_id()		else:			port = device_id		print ("using output_id :%s:" % port)		# no latency no scheduling of midi events with timestamp		self.midi_out = pygame.midi.Output(port, latency = 1)		'''				self.midi_out = kwargs.get('midi_out')						# setup output		#self.output=OutputAdapter.OutputAdapter(manager=self, logging=self.__logging)		self.output=OutputAdapter.Output(manager=self, logging=self.__logging, midi_out=self.midi_out)		#self.output.setDaemon(True)		self.__callbacks={} # dictionary for callback methods <obj>:<callback>				self.__sequenceCounter = -1				sys.modules['EventManagerInstance']=self	''' register an object '''	def register(self, object, method):		self.__log('registering callback method for ' + str(object.id))		self.__callbacks[object]=method		# tell worker to get new registered method:		self.worker.refreshConfig.set()	''' unregister an object '''	def unregister(self, object):		self.__log('unregistering callback method for ' + str(object.id))		del self.__callbacks[object]		# tell worker to get new registered method:		self.worker.refreshConfig.set()			''' for EventWorker to fetch it '''	def getCallbacks(self):		return self.__callbacks	''' set speed in bpm = beats per minute '''	def setBPM(self,bpm):		self.output.setBPM(bpm)	''' tunnel for log messages '''	def __log(self, msg):		if(self.__logging):			print 'EventManager:\t' + msg	''' get next Sequence ID from internal counter 		this method should be used each time a sequence		is instantiated so there are no duplicates	'''	def getNextSequenceID(self):		self.__sequenceCounter = self.__sequenceCounter + 1		print self.__sequenceCounter		return self.__sequenceCounter				''' make new sequence '''	def createSequence(self):		seq = Sequence.Sequence(id=self.getNextSequenceID(),logging=Constants.LOGGING_sequences)		self.register(seq, seq.getMidiData)		return seq	''' mainloop '''	def run(self):		# start EventWorker-Thread		self.__log('starting EventWorker-Thread')		self.worker.start()		# start OutputAdapter-Thread		self.__log('starting OutputAdapter-Thread')		self.output.start()									def print_device_info(self):		pygame.midi.init()		self._print_device_info()		pygame.midi.quit()	def _print_device_info(self):		for i in range( pygame.midi.get_count() ):			r = pygame.midi.get_device_info(i)			(interf, name, input, output, opened) = r			in_out = ""			if input:				in_out = "(input)"			if output:				in_out = "(output)"			print ("%2i: interface :%s:, name :%s:, opened :%s:  %s" %				(i, interf, name, opened, in_out))		